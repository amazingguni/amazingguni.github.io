---
layout: post
title: 클린코드 5장 - 형식 맞추기
excerpt: "Cleancode"
tags: [CleanCode, 형식, formatter, format]
comments: true
---

`CleanCode 5장 형식 맞추기` 에 대해 정리한 포스트입니다.  

### Overview

프로그래머라면 형식을 깔끔하게 맞춰 코드를 짜야 합니다. 코드 형식을 맞추기 위해 규칙을 정하고 일관성 있게 지켜야 합니다

* 코드를 본 독자들이 깔끔하고 일관적이며 꼼꼼하다고 감탄하면 좋겠다.
* 질서 정연하다고 탄복하면 좋겠다.
* 전문가가 짰다는 인상을 심어주면 좋겠다.
* 규칙을 적용하는 툴을 활용하는 것도 좋다.

### 1. 형식을 맞추는 이유

일단 코드 형식은 의사 소통의 일환이고 전문 개발자의 일차적인 의무이기 때문에 아주 **중요합니다**.

* 오늘 구현한 기능이 다음 버전에서 바뀔 확률이 아주 높다.
* 그 때문에 오늘 구현한 코드의 가독성은 앞으로 바뀔 코드의 품질에 지대한 영향을 미침
* 원래 코드의 흔적이 없어지더라도 처음 잡은 **구현 스타일**과 **가독성 수준**은 계속 영향을 미침.

> 형상 관리 도구에서 포멧으로 인한 Diff를 방지하기 위해서도 필요합니다.

### 2. 적절한 행 길이를 유지하라

큰 파일보다 작은 파일이 일반적으로 이해하기 쉽습니다.

* 200줄 미만의 코드로도 충분히 크고 복잡한 시스템을 만들 수 있습니다.

### 3. 신문 기사처럼 작성하라

소스 파일은 신문 기사와 비슷하게 작성합니다.

1. 이름은 간단하면서도 설명이 가능하게 짓는다. 
2. 소스 파일 첫 부분은 고차원 개념과 알고리즘을 설명
3. 아래로 내려갈수록 의도를 세세하게 묘사
4. 마지막에는 가장 저차원 함수와 세부 내역

> 대다수 기사는 아주 짧습니다(몇몇개는 길지만). 신문이 아주 긴 하나의 기사만 싣는다면 아무도 읽지 않을 것입니다.

### 4. 개념은 빈 행으로 분리하라

* 각 행은 수식이나 절을 나타내고 일련의 행 묶음은 완결된 생각 하나를 표현
* 생각 사이에는 빈 행을 넣어 분리

```
package fitnesse.wikitext.widgets;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class BoldWidget extends ParentWidget {
	public static final String REGEXP = "'''.+?'''";
	private static final Pattern pattern = Pattern.compile("'''(.+?)'''",
		Pattern.MULTILINE + Pattern.DOTALL
	);

	public BoldWidget(ParentWidget parent, String text) throws Exception {
		super(parent);
		Matcher match = pattern.matcher(text);
		match.find();
		addChildWidgets(match.group(1));
	}

	public String render() throws Exception {
		StringBuffer html = new StringBuffer("<b>");
		html.append(childHtml()).append("</b>");

	    return html.toString();
	}
}
```

```
package fitnesse.wikitext.widgets;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
public class BoldWidget extends ParentWidget {
	public static final String REGEXP = "'''.+?'''";
	private static final Pattern pattern = Pattern.compile("'''(.+?)'''",
		Pattern.MULTILINE + Pattern.DOTALL
	);
	public BoldWidget(ParentWidget parent, String text) throws Exception {
		super(parent);
		Matcher match = pattern.matcher(text);
		match.find();
		addChildWidgets(match.group(1));
	}
	public String render() throws Exception {
		StringBuffer html = new StringBuffer("<b>");
		html.append(childHtml()).append("</b>");
	    return html.toString();
	}
}
```

### 5. 세로 밀집도

세로 밀집도는 연관성을 의미합니다.

* 즉 서로 밀접한 코드 행은 세로로 가까이 놓여야 합니다.

``` java
public class ReporterConfig {
    /**
     * 리포터 리스너의 클래스 이름
    */
    private String m_className;

    /**
     * 리포터 리스너의 속성
    */
    private List<Property> m_properties = new ArrayList<Property>();
    public void addProperty(Property property) {
        m_properties.add(property);
}
```

``` java
public class ReporterConfig {
    private String m_className;
    private List<Property> m_properties = new ArrayList<Property>();

    public void addProperty(Property property) {
        m_properties.add(property);
}
```

### 6. 수직 거리

서로 밀접한 개념은 같은 파일에 속하는 것이 좋습니다.

* 무엇을 하는지 이해하기 위해 이 조각 저 조각이 **어디**에 있는지 찾고 기억해야 함

> 함수나 변수가 정의된 코드를 찾으러 상속 관계를 거슬러 올라간 경험이 있다면 공감할 것이다.

같은 파일에 속할 정도로 밀접한 두 개념은 세로 거리로 연관성을 표현합니다.

* 연관성이 깊은 두 개념이 멀리 떨어져 있으면 코드를 읽는 사람이 여기저기 뒤져야 함

1. 변수 선언
	* 변수는 사용하는 위치에 최대한 가까이 선언
	* 지역 변수는 각 함수 맨 처음에 선언(우리가 만들 함수는 짧을 테니)
	
	```java
	private static void readPreferences() {
		InputStream is = null;
		try {
			is = new FileInputStream(getPreferencesFile());
			setPreferences(new Properties(getPreferences()));
			getPreferences().load(is);
		} catch (IOException e) {
			try {
				if (is != null)
					is.close();
			} catch (IOException e1) {
			}
		}
	}
	```
	* loop문 제어 변수는 loop문 내부에 선언

	```java
		public int countTestCases() {
		int count = 0;
		for (Test each : tests)
			count += each.countTestCases();
		return count;
	}
	```

2. 인스턴스 변수
	* 변수를 선언하는 위치는 잘 알려진 위치여야 합니다.
		* 클래스 맨 처음에 선언(java), 클래스 마지막에 선언(c/c++, scisors rule)
	* Method 중간에 숨겨두면 찾기 어려워진다.

3. 종속 함수
	* 한 함수가 다른 함수를 호출한다면 두 함수는 세로로 가까이 배치
	* 가능하다면 호출하는 함수를 호출되는 함수보다 먼저 배치
		* 코드가 자연스럽게 읽힘(높은 추상화 -> 낮은 추상화)
		* 이 규칙이 일관적으로 적용되면 독자는 방금 호출된 함수가 곧 정의될 거라 예측할 수 있습니다.

	``` java
	public class WikiPageResponder implements SecureResponder {
	  @Override
	  public Response makeResponse(FitNesseContext context, Request request) {
		WikiPage page = loadPage(context, request.getResource(), request.getMap());
		if (page == null)
		  return notFoundResponse(context, request);
		else
		  return makePageResponse(context, page);
	  }

	  protected WikiPage loadPage(FitNesseContext context, String pageName, Map<String,String> inputs) {
		WikiPage page;
		if (RecentChanges.RECENT_CHANGES.equals(pageName)) {
		  page = context.recentChanges.toWikiPage(context.getRootPage());
		} else {
		  WikiPagePath path = PathParser.parse(pageName);
		  PageCrawler crawler = context.getRootPage(inputs).getPageCrawler();
		  page = crawler.getPage(path);
		}
		return page;
	  }

	  private Response notFoundResponse(FitNesseContext context, Request request) {
		if (dontCreateNonExistentPage(request))
		  return new NotFoundResponder().makeResponse(context, request);
		return new EditResponder().makeResponseForNonExistentPage(context, request);
	  }

	  private boolean dontCreateNonExistentPage(Request request) {
		String dontCreate = request.getInput("dontCreatePage");
		return dontCreate != null && (dontCreate.isEmpty() || Boolean.parseBoolean(dontCreate));
	  }

	  private SimpleResponse makePageResponse(FitNesseContext context, WikiPage page) {
		  String html = makeHtml(context, page);

		  SimpleResponse response = new SimpleResponse();
		  response.setMaxAge(0);
		  response.setContent(html);
		  return response;
	  }
	```
	
