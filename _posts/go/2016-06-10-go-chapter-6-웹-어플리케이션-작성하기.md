---
layout: post
title: 디스커버리 Go 5 - 웹 애플리케이션 작성하기
excerpt: "Go"
tags: [Go, GOROOT, GOPATH]
comments: true
---

이 포스트는 `디스커버리 GO 언어` 6장을 읽고 정리한 것이며 작업 환경은 `Ubuntu 16.04`입니다. 소스를 기반으로 설명하는 형태로 진행합니다.  

> 중간에 필요한 경우 첨언합니다.

## 6.1 Hello, 세계!

브라우저로 *http://localhost:8080*으로 접속하면 "Hello, 세계!"를 보여주는 예제입니다.


``` go
func main() {
	http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
		fmt.Fprintln(w, "Hello, 세계!")
	})
	log.Fatal(http.ListenAndServe(":8080", nil))
}
```

curl로도 확인할 수 있습니다.

```sh
$ curl http://localhost:8080
Hello, 세계!
```

## 6.2 할 일 목록 관리 웹 앱 만들기

할 일 목록을 관리하는 웹 앱을 만들어보겠습니다. 이름은 *TaskMan* 입니다.

* 끝까지 구현하지는 않습니다.

### 6.2.1 RESTful API

* GET, PUT, POST, DELETE 메소드를 이용하여 어떤 동작을 취할 지 지정하는 API(자세한 설명은 생략한다)
* *http://example.com/abc/def?q=ghi* 에서 */abc/def* 는 URL 경로, *q=ghi* 는 쿼리가 됩니다.
* 각각의 resource에는 ID가 부여됩니다(/task/123)

### 6.2.2 Data Access Object

DAO^Data ^Access ^Object 란 데이터베이스에 필요한 연산들을 처리하기 위해서 만드는 추상 인터페이스입니다.

* 사용하는 데이터베이스와 비지니스 로직을 분리할 수 있는 방법

```go
package task

// ID is a data type to identify the task.
type ID string

// Accessor is an interface to access the tasks.
type Accessor interface {
    Get(id ID) (Task, error)
    Put(id ID, t Task) error
    Post(t Task) (ID, error)
    Delete(id ID) error
}
```

*Accessor* interface 를 상속받는 *MemoryDataAccess* 를 구현합니다.

```go
package task

import (
    "errors"
    "fmt"
)


type MemoryDataAccess struct {
    tasks  map[ID]Task
    nextID int64
}

func NewMemoryDataAccess() Accessor {
    return &MemoryDataAccess{
        tasks:map[ID]Task{},
        nextID: int64(1),
    }
}

var ErrTaskNotExist = errors.New("task does not exist")

func (m *MemoryDataAccess) Get(id ID) (Task, error) {
    t, exists := m.tasks[id]
    if !exists {
        return Task{}, ErrTaskNotExist
    }
    return t, nil
}

func (m *MemoryDataAccess) Put(id ID, t Task) error {
    if _, exists := m.tasks[id]; !exists {
        return ErrTaskNotExist
    }
    m.tasks[id] = t
    return nil
}

func (m *MemoryDataAccess) Post(t Task) (ID, error) {
    id := ID(fmt.Sprint(m.nextID))
    m.nextID++
    m.tasks[id] = t
    return id, nil
}

func (m *MemoryDataAccess) Delete(id ID) error {
    if _, exists := m.tasks[id]; !exists {
        return ErrTaskNotExist
    }
    delete(m.tasks, id)
    return nil
}
```

### 6.2.3 RESTful API 핸들러 구현

```
GET /api/v1/task/{id}

PUT /api/v1/task/{id}
task: {task}

POST /api/v1/task/
task: {task}

DELETE /api/v1/task/{id}
```

#### response.go

Client의 request에 돌려주는 Response 객체를 정의합니다.

이 Response 객체를 json으로 변환하기 위한 것들을 정의해줍니다.

* JSON tag를 Response 객체에 정의 \`json:"task"\`
* ResponseError 객체에 *MarshalJSON()*, *UnmarshalJSON()* 를 정의

```go
package main

import (
    "fmt"
    "encoding/json"
    "errors"
    "github.com/amazingguni/gogo/task"
)

type ResponseError struct {
    Err error
}

func (err ResponseError) MarshalJSON() ([]byte, error) {
    if err.Err == nil {
        return []byte("null"), nil
    }
    return []byte(fmt.Sprintf("\"%v\"", err.Err)), nil
}

func (err *ResponseError) UnmarshalJSON(b []byte) error {
    var v interface{}

    if err := json.Unmarshal(b, v); err != nil {
        return err
    }
    if v == nil {
        err.Err = nil
        return nil
    }

    switch tv := v.(type){
    case string:
        if tv == task.ErrTaskNotExist.Error() {
            err.Err = task.ErrTaskNotExist
            return nil
        }
        err.Err = errors.New(tv)
        return nil
    default:
        return errors.New("ResponseError unmarshal failed")
    }
}

type Response struct {
    ID    task.ID       `json:"id,omitempty"`
    Task  task.Task     `json:"task"`
    Error ResponseError `json:"error"`
}
```


